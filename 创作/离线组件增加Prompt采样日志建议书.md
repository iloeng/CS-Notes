# 技术备忘：关于在离线Embedding组件中增加“原始Prompt采样日志”的建议

## 背景 (Context)
我们在使用离线组件构造Prompt并刷Embedding时，需要对输入给LLM的原始Prompt进行调试和校验。目前组件缺乏对原始输入的日志输出，导致无法直观看到经过处理后的最终Prompt长什么样。

## 现状与问题 (Problem Statement)
1.  **下游黑盒化**：下游LLM调用是一个黑盒过程。如果没有输入日志，我们只能看到Embedding结果，无法确切知道到底传了什么给模型。一旦效果不符合预期，无法区分是“Prompt拼错了”还是“模型理解偏了”。
2.  **调试链路长**：目前想要看Prompt，需要研发手动修改组件代码加入 `print`，然后重新编译/运行。
3.  **协作壁垒**：产品（PM）、算法同学如果想看Prompt逻辑，必须依赖研发改代码，无法自助排查，阻塞了非代码贡献者的调试路径。

## 核心建议 (Proposal)
在组件核心处理逻辑处，增加一行 **采样日志 (Sampling Log)**，打印发送给下游的原始Prompt。
*   **实现方式**：`Logger.info("Raw Prompt Input: %s", prompt)`
*   **控制策略**：为避免日志爆炸，可设置采样率（如 1%）或仅在 `debug_mode=True` 时全量打印。

## 价值分析 (Value Proposition)

### 1. 提升研发效能与调试速度 (DevEx)
*   **所见即所得**：Prompt工程是一个高频迭代的过程（修改->看输入->看效果）。支持日志输出能将反馈闭环从“改代码+重跑”缩短为“改配置+看日志”，极大地提升调试效率。
*   **解除手动操作的低效**：官方建议的“每次想看就自己手改一行代码”，在工程实践上是反模式的。它增加了由于手动hack代码带来的脏数据风险，且严重拖慢了多人协作时的排查速度。

### 2. 增强系统的可观测性与可追溯性 (Observability)
*   **事故复盘**：当线上或离线任务出现Embedding质量异常时，原始输入日志是唯一的“案发现场”。保留采样日志意味着我们拥有了追溯问题的抓手。
*   **白盒化验证**：对于产品和算法同学，看到的不再是一个黑盒的Embedding向量，而是可读的文本逻辑，有助于上下游对齐业务逻辑。

### 3. 极低成本，无副作用 (Low Cost, High Return)
*   这是一个 **Low Effort, High Leverage** 的改动。代码层面仅需增加 1-2 行日志调用，对组件的核心功能、性能（在采样前提下）均无负面影响。

## 针对异议的回应：关于“QA已验证” (Addressing Counter-Arguments)
针对“QA已经验证过标品固定Prompt逻辑，因此无需日志”的观点，我们认为存在以下误区，不能成为拒绝日志的理由：

### 1. 验证范围不同 (Scope Mismatch: Logic vs. Semantics)
*   **QA验证的是逻辑**：QA侧重于保证代码按预期运行（Functional Correctness），例如字符串拼接未报错、必填字段未缺失。
*   **我们需要Check的是效果**：日志需求侧重于**语义效果的确认**（Semantic Effectiveness）。Prompt拼接正确不代表对LLM的效果最好。算法和产品需要通过查看实际的Prompt Case，来评估在特定数据分布下是否存在歧义或优化空间。**QA的Pass不代表业务效果的Pass**。

### 2. 静态验证无法覆盖动态数据 (Static Verification vs. Dynamic Data)
*   QA验证基于有限的测试用例集。但实际业务数据千变万化（如特殊字符、超长文本、多语言混合等），固定的Prompt逻辑在遇到新的长尾数据时可能表现异常。
*   **日志是唯一的“案发现场”**：当线上出现Bad Case时，如果没有采样日志，我们无法判断是数据源问题、Prompt拼接问题还是模型问题。保留日志是系统健壮性的体现。

### 3. 关键链路的数据留存 (Critical Data Retention)
*   **填补下游日志真空**：下游LLM服务是黑盒且**明确不记录详细的请求体日志**。这意味着如果我们不记录，整个调用链路的原始输入将彻底丢失（Data Loss）。
*   **事故复盘的刚需**：一旦发生Embedding效果异常或线上事故，保留原始信息是进行**信息追溯（Traceability）**和**事故复盘（Post-mortem）**的唯一依据。没有日志将导致“死无对证”，无法界定是上游拼接问题还是下游模型问题。

### 4. 信任但验证 (Trust, but Verify)
*   系统设计应遵循**透明化**原则。QA验证通过是上线的必要条件，但不是拒绝提供可观测手段的理由。
*   保留原始信息是为了在出现争议或问题时，各方（产品/算法/研发）能有独立的证据链进行追溯，而不是盲目信任单一环节的结论。

## 总结 (Conclusion)
“是否打印日志”不应仅被视为一个业务需求（Product Feature），它本质上是**技术基础设施的可服务性（Serviceability）**需求。
在一个黑盒调用的系统中，**保留对原始输入的可见性是底线要求**。建议尽快合入此改动，释放上下游研发与产品同学的生产力。
